문제 조건을 보면 격자판의 행: 10,000개, 열: 최대 1,000,000개,
→ 즉 최대 1천만 × 1만 = 100억 개의 셀, int 기준 40GB 메모리입니다.

=> 절대 배열을 int[10000][C] 같이 만들면 안 됩니다.

이건 메모리 초과입니다. 대신 다음과 같이 문제를 풀어야 합니다.

핵심 아이디어: 열 단위 상태만 관리하면 충분

블록은 “위에서 아래로 떨어지기” 때문에,
**열마다 가장 위에 쌓인 블록의 높이(=행 위치)**만 알면 충분해요.

-------------------------------------------------

현재 구현 (O(mLength))의 문제점

   * `dropBlocks` 당 연산 수: update 함수는 mLength에 비례하는 연산을 수행합니다. mLength가 최대
     1,000,000이므로, 최악의 경우 dropBlocks 한 번에 약 1,000,000번의 연산이 필요합니다.
   * 테스트케이스 당 총 연산 수: 3,000번 호출 × 1,000,000 연산/호출 ≈ 3,000,000,000 (30억)
   * 전체 연산 수: 50개 TC × 30억 연산/TC ≈ 150,000,000,000 (1,500억)

  이는 일반적인 제한 시간(1~2초, 약 1억~2억 번의 연산)을 훨씬 초과하는 계산량이므로 시간 초과가
  발생하는 것이 당연합니다.

  Lazy Propagation 적용 시 (O(log C))의 기대 효과

   * `dropBlocks` 당 연산 수: Lazy Propagation을 적용하면 update 함수의 시간 복잡도는 구간의 길이에
     상관없이 트리의 높이에 비례하는 O(log C)가 됩니다.
       * C(열의 개수)가 최대 1,000,000일 때, log₂(1,000,000)는 약 20입니다. 즉, dropBlocks 한 번에 약
         20번의 연산만 필요합니다.
   * 테스트케이스 당 총 연산 수: 3,000번 호출 × 20 연산/호출 ≈ 60,000 (6만)
   * 전체 연산 수: 50개 TC × 6만 연산/TC ≈ 3,000,000 (300만)

  이 계산량은 제한 시간 내에 충분히 수행 가능합니다.